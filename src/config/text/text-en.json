{
  "appName": "Super Numerical Methods",
  "appSettings":{
    "discardButton": "Discard",
    "function.globalFx.helpText": "Set a global function for f(x)",
    "function.globalFx.label": "Global f(x)",
    "function.globalGx.helpText": "Set a global function for g(x)",
    "function.globalGx.label": "Global g(x)",
    "function.title": "Function Settings",
    "saveButton": "Save",
    "saveSuccess": "Changes were successfully saved!",
    "sysOfLinEquations.globalColRow.helpText": "Number of rows and columns for the A/B matrix",
    "sysOfLinEquations.globalColRow.label": "Number of rows and columns",
    "sysOfLinEquations.title": "Systems of linear equations"
  },
  "common": {
    "aMatrixNotDefined": "Matrix A is not completely defined!",
    "absoluteError": "Absolute",
    "bMatrixNotDefined": "Matrix B is not completely defined!",
    "bisection": "Bisection",
    "cancel": "Cancel",
    "close":"Close",
    "collapse": "Collapse",
    "confirmDelete": "Are you sure you want to delete record '{0}'?",
    "currentIteration": "Phase {0}",
    "currentSortingIteration": "Step {0}",
    "currentX": "x{0}",
    "currentY": "y{0}",
    "d2fxn": "f''(x)",
    "delete": "Delete",
    "delta": "Delta",
    "delta.helpText": "Set the increment value",
    "den": "Denominator",
    "dfxn": "f'(x)",
    "edit": "Edit",
    "errorType": "Choose type of error",
    "execute": "Execute",
    "executeMethodSuccess": "The method was successfully executed!",
    "expand": "Expand",
    "export": "Export",
    "falseRule": "False rule",
    "finalIteration": "Final phase",
    "formType": "Choose type of form",
    "fx": "f(x)",
    "fxNotDefined": "f(x) is not defined!",
    "fxm": "f(xm)",
    "fxn": "f(xn)",
    "getBestLambda": "Get best lambda",
    "gxNotDefined": "g(x) is not defined!",
    "iterMethodsTitle": "Iterative methods",
    "iterations": "Max iterations (n)",
    "lambda": "λ",
    "methodType": "Choose type of method",
    "n": "n",
    "new": "New",
    "numberColRow": "Number of columns/rows (nxn)",
    "options": "Options",
    "pointsQuantity": "Number of points",
    "polynomialEquation": "Polynomial equation",
    "relativeError": "Relative",
    "save": "Save",
    "solution": "Solution",
    "sortingIterations": "Sorting steps",
    "terms": "Terms",
    "titleBisFalse": "Bisection and false Rule",
    "titleFixedPoint": "Fixed-point iteration",
    "titleIncrSearch": "Incremental search",
    "titleMultRoots": "Multiple roots",
    "titleNewton": "Newton",
    "titleSecant": "Secant",
    "tolerance": "Tolerance",
    "tolerance.helpText": " Set the tolerance value",
    "toleranceError": "Error",
    "view": "View",
    "x": "x",
    "x0": "x0",
    "x1": "x1",
    "xi": "xi",
    "xm": "xm",
    "xn": "xn",
    "xs": "xs"
  },
  "factorizationLU": {
    "cholesky": "Cholesky",
    "crout": "Crout",
    "doolittle": "Doolittle"
  },
  "footer": {
    "copyright": "© 2020, developed by Juan Carlos Estrada Alvarez"
  },
  "gaussElimination": {
    "complete": "Complete pivoting",
    "partial": "Partial pivoting",
    "simple": "Simple"
  },
  "interpolationNewtonLagrange": {
    "newton": "Newton",
    "lagrange": "Lagrange"
  },
  "helpMessages":{
    "bisFalseHelp": "These methods consist of reducing the interval containing the root in two subintervals, either by mean value or by intersection between a secant formed by the two points of the interval and the x-axis. After that, the interval that continues to maintain the initial characteristics is preserved. In this way, a succession of midpoints is constructed that ends up converging to the root value.",
    "factorizationHelp": "The LU factorization seeks to replace matrix A with two triangular matrices whose product is equal to it. The first matrix is lower triangular L and the second is upper triangular U. In this sense, the system Ax = b stops to become two systems: Lz = b and Ux = z. The difference between the three methods is how the L and U matrices are calculated. These forms start from: cholesky: Lii = Uii, doolittle: Lii = 1 and crut: Uii = 1.",
    "fixedPointHelp": "This method calculates an approximation to a root by finding an intersection between the function y = x and the equation x = g (x) where g (x) is an equation equivalent to f (x) = 0 that results from applying clearances and substitutions. . To calculate the root or an approximate value, calculate x that in each iteration approaches the true value.",
    "gaussEliminationHelp": "These methods seek to find the values of the n unknowns of a system of equations, satisfying the equation Ax = b. For this, the methods are based on two fundamental phases, the transformation of the matrix converting it into an upper triangular matrix U and the clearance of the variables by means of a regressive substitution. What sets the three methods apart is the way you do row or column swap operations under criteria",
    "incrSearchHelp": "This method is used to search for those subintervals in which the existence of a root is guaranteed. An equation (f (x) = 0), an interval ([a, b]) and an increment (delta ∆) are given. It consists of starting from one end of the interval (a), evaluating in the function and adding the increment to it. It ends when there is a change of sign.",
    "integrationHelp": "Integration methods are used to find the integral in the interval with certain points. For this, we rely on the approximations of the functions by means of interpolating polynomials, and depending on the number of points, the integral can be found by different methods.",
    "interpolationHelp": "Interpolation methods allow modeling the behavior of a mathematical phenomenon by means of a set of previously acquired points. For the project we have developed three ways to acquire the interpolating polynomial. These methods find the polynomial of degree n that passes through n + 1 given points and each one has its generalized way of finding it.",
    "iterativeMethodsHelp": "They are a generalization of the fixed point method, they behave in such a way that, from a vector x0 (of initial values), in each iteration an approximation is found that is expected to be closer to the real value than the previous one. To find the equation x = g (x), all x's of the vector whose coefficients are expected to be the largest possible are solved, thus avoiding divisions by zero.",
    "multRootsHelp": "This is a useful method to find an approximation to a root, when the previous methods lose convergence speed due to an approximation of the derivative of the function f (x) to the value 0, mainly when the root is positioned on a maximum or a minimum, that is, there is a multiple root.",
    "newtonHelp": "It can be seen as a variant of the fixed point method. Therefore it will try to find an approximation to the root by means of a succession of values given an expression of the form x = g (x). However, here we will know that g (x) = x - f (x) / f ’(x). In other words, each x is generated by means of the intersection between the x axis and the tangent to the curve y = f (x) at the point given at the time of the iteration.",
    "secantHelp": "It is a variant of Newton's method and transitively of the fixed point method. Therefore, like the previous ones, it searches for an approximation to the root iteratively by means of the succession of values that are expected to converge to a value. It is ideal when the derivative of the function f (x) is too complex, then the secant method will find an approximation to said derivative by means of limits.",
    "splineHelp": "With the splines or tracers method, we seek to find an interpolating polynomial given by a polynomial function that is defined by sections where each of them is a polynomial. To define the polynomial, certain conditions must be met, such as continuity in points and smoothness."
  },
  "homePage": {
    "content": "Welcome!"
  },
  "integration": {
    "general": "General",
    "simple": "Simple",
    "simpson13": "Simpson 1/3",
    "simpson38": "Simpson 3/8",
    "trapeze": "Trapeze"
  },
  "iterativeMethods": {
    "gauss": "Gauss-Seidel",
    "jacobi": "Jacobi"
  },
  "modalDialog": {
    "cancel": "Cancel",
    "msg": "Are you sure you want to perform this action?",
    "ok": "Ok",
    "title": "Confirm"
  },
  "multiselect": {
    "search": "Search",
    "selectAll": "Select all"
  },
  "notFoundPage": {
    "content": "The resource you are looking for has been removed, had its name changed, or is temporarily unavailable."
  },
  "notifications": {
    "delete": "The record was successfully deleted!",
    "insert": "The record was successfully inserted!",
    "update": "The record was successfully updated!"
  },
  "routes": {
    "bisecFalseRule": "Bisection/False rule",
    "closedMethods": "One-variable closed methods",
    "factorizationLU": "Factorization",
    "fixedPoint": "Fixed-point iteration",
    "gaussElimination": "Gaussian elimination",
    "home": "Home",
    "incrSearch": "Incremental search",
    "integration": "Integration",
    "interpolation": "Interpolation",
    "interpolationNewtonLagrange": "Newton/Lagrange",
    "interpolationSplines": "Splines",
    "iterMethods": "Iterative Methods",
    "multipleRoots": "Multiple Roots",
    "newton": "Newton",
    "openMethods": "One-variable open methods",
    "secant": "Secant",
    "settings": "Settings",
    "sysOfLinEquations": "Systems of linear equations"
  },
  "textFieldPlaceHolders": {
    "email": "email@company.com",
    "phone": "(555) 555-5555",
    "zip": "12345 / 12345-6789"
  },
  "topBar": {
    "alerts": "Alerts",
    "collapse": "Collapse",
    "expand": "Expand",
    "profile": "My profile"
  },
  "validations": {
    "date": "Invalid date",
    "email": "Invalid email",
    "maxValue": "Max value: {0}",
    "minCharacters": "Expected at least {0} characters",
    "minValue": "Min value: {0}",
    "number": "Invalid number",
    "phone": "Invalid phone",
    "required": "Required field",
    "search": "Invalid search",
    "verification": "Verification doesn't match",
    "zip": "Invalid zip code"
  }
}
